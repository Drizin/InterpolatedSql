using Dapper;
using InterpolatedSql.SqlBuilders;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;

namespace InterpolatedSql.Dapper
{
    /// <summary>
    /// Maps from <see cref="InterpolatedSql.SqlParameterInfo" /> to Dapper Parameters.
    /// </summary>
    public class SqlParameterMapper
    {
        /// <inheritdoc />
        public SqlParameterMapper()
        {
        }

        /// <summary>
        /// Calculates the name automatically assigned to interpolated parameters
        /// </summary>
        public virtual string CalculateAutoParameterName(InterpolatedSqlParameter parameter, int pos, InterpolatedSqlBuilderOptions options)
        {
            return options.AutoGeneratedParameterPrefix +
                pos.ToString() +
                (IsEnumerable(parameter.Argument) ? options.ParameterArrayNameSuffix : "");
        }

        /// <summary>
        /// Dapper treats arrays/lists as table-valued parameters or lists for IN clauses,
        /// we just use this information for renaming parameters to prevent a rare name conflict.
        /// </summary>
        protected bool IsEnumerable(object? value)
        {
            if (value != null && value is SqlParameterInfo)
                value = ((SqlParameterInfo)value).Value;
            if (value == null || value is DBNull)  //SqlMapper.GetDbType
                return false;
            Type t = value.GetType();
            return t != typeof(string) && typeof(IEnumerable).IsAssignableFrom(t);
            //TODO: use Dapper SqlMapper.LookupDbType ?
        }

        /// <summary>
        /// Converts from<see cref= "InterpolatedSql.SqlParameterInfo" /> to Dapper Parameters.
        /// </summary>
        public virtual void AddToDynamicParameters(DynamicParameters target, SqlParameterInfo parameter)
        {
            // This behaves like Options.Parser.TransformArgument, but for Dapper parameters
            //TODO: do implicit parameters have names here?!
            if (parameter is DbTypeParameterInfo dbParm)
                target.Add(parameter.Name!, parameter.Value, dbParm.DbType, parameter.ParameterDirection ?? ParameterDirection.Input, dbParm.Size);
            else if (parameter is StringParameterInfo stringParm)
                target.Add(parameter.Name!, new DbString() { Value = (string?)stringParm.Value, IsAnsi = stringParm.IsAnsi, IsFixedLength = stringParm.IsFixedLength, Length = stringParm.Length });
            else if (parameter is SqlParameterInfo parm && parm.Value is IEnumerable<StringParameterInfo> stringParms)
            {
                target.Add(parameter.Name!, stringParms.Select(stringParm => new DbString() { Value = (string?)stringParm.Value, IsAnsi = stringParm.IsAnsi, IsFixedLength = stringParm.IsFixedLength, Length = stringParm.Length }));
            }
            else
                target.Add(parameter.Name!, parameter.Value);
        }

        /// <summary>
        /// Default mapper. By inheriting/overriding it's possible to modify this behavior
        /// </summary>
        public static SqlParameterMapper DefaultMapper { get; set; } = new SqlParameterMapper();
    }
}
