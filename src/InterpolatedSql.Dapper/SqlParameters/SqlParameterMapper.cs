using Dapper;
using InterpolatedSql.SqlBuilders;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Data;
using System.Linq;

namespace InterpolatedSql.Dapper
{
    /// <summary>
    /// Maps from <see cref="InterpolatedSql.SqlParameterInfo" /> to Dapper Parameters.
    /// </summary>
    public class SqlParameterMapper
    {
        /// <inheritdoc />
        public SqlParameterMapper()
        {
        }

        /// <summary>
        /// Calculates the name automatically assigned to interpolated parameters
        /// </summary>
        public virtual string CalculateAutoParameterName(InterpolatedSqlParameter parameter, int pos, InterpolatedSqlBuilderOptions options)
        {
            return options.AutoGeneratedParameterPrefix +
                pos.ToString() +
                (IsEnumerable(parameter.Argument) ? options.ParameterArrayNameSuffix : "");
        }

        /// <summary>
        /// Dapper treats arrays/lists as table-valued parameters or lists for IN clauses,
        /// we just use this information for renaming parameters to prevent a rare name conflict.
        /// </summary>
        protected bool IsEnumerable(object? value)
        {
            if (value != null && value is SqlParameterInfo)
                value = ((SqlParameterInfo)value).Value;
            if (value == null || value is DBNull)  //SqlMapper.GetDbType
                return false;
            Type t = value.GetType();
            return t != typeof(string) && typeof(IEnumerable).IsAssignableFrom(t);
            //TODO: use Dapper SqlMapper.LookupDbType ?
        }

        /// <summary>
        /// Converts from<see cref= "InterpolatedSql.SqlParameterInfo" /> to Dapper Parameters.
        /// </summary>
        public virtual void AddToDynamicParameters(DynamicParameters target, SqlParameterInfo parameter)
        {
            // This behaves like Options.Parser.TransformArgument, but for Dapper parameters

            if (parameter is DbTypeParameterInfo dbParm)
                target.Add(parameter.Name!, parameter.Value, dbParm.DbType, parameter.ParameterDirection ?? ParameterDirection.Input, dbParm.Size);
            else if (parameter is StringParameterInfo stringParm)
                target.Add(parameter.Name!, new DbString() { Value = (string?)stringParm.Value, IsAnsi = stringParm.IsAnsi, IsFixedLength = stringParm.IsFixedLength, Length = stringParm.Length });
            else if (parameter is SqlParameterInfo parm && parm.Value is IEnumerable<StringParameterInfo> stringParms)
            {
                target.Add(parameter.Name!, stringParms.Select(stringParm => new DbString() { Value = (string?)stringParm.Value, IsAnsi = stringParm.IsAnsi, IsFixedLength = stringParm.IsFixedLength, Length = stringParm.Length }));
            }
            else
                target.Add(parameter.Name!, parameter.Value);
        }

        public virtual ParametersDictionary GetParametersDictionary(IInterpolatedSql sql, InterpolatedSqlBuilderOptions? options = null)
        {
            return GetParametersDictionary(sql.SqlParameters, sql.ExplicitParameters, options);
        }

        public virtual ParametersDictionary GetParametersDictionary(IEnumerable<InterpolatedSqlParameter> sqlParameters, IEnumerable<SqlParameterInfo> explicitParameters, InterpolatedSqlBuilderOptions? options = null)
        {
            var parameters = new ParametersDictionary();
            //HashSet<string> parmNames = new HashSet<string>(StringComparer.OrdinalIgnoreCase); //TODO: check for name clashes, rename as required

            options ??= InterpolatedSqlBuilderOptions.DefaultOptions;

            foreach (var explicitParameter in explicitParameters)
            {
                parameters.Add(explicitParameter);
            }
            for (int i = 0; i < sqlParameters.Count(); i++)
            {
                var sqlParameter = sqlParameters.ElementAt(i);
                var parmName = CalculateAutoParameterName(sqlParameter, i, options);
                var parmValue = sqlParameter.Argument;
                var format = sqlParameter.Format;
                if (!string.IsNullOrWhiteSpace(format))
                    throw new ArgumentException("Unrecognized format modifier: " + format);
                if (parmValue is SqlParameterInfo parm)
                {
                    parm.Name = parmName;
                    parameters[parmName] = parm;
                }
                else
                    parameters.Add(new SqlParameterInfo(parmName, parmValue));
            }
            return parameters;
        }

        /// <summary>
        /// Default mapper. By inheriting/overriding it's possible to modify this behavior
        /// </summary>
        public static SqlParameterMapper DefaultMapper { get; set; } = new SqlParameterMapper();
    }
}
